
Перевод, оригинал находится в [блоге автора](https://ferd.ca/the-zen-of-erlang.html).

## *Введение от переводчика*

*В данной статье речь идёт об [Erlang](https://ru.wikipedia.org/wiki/Erlang), но всё сказанное в равной степени применимо и к [Elixir](https://ru.wikipedia.org/wiki/Elixir_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) - функциональному языку, работающему поверх той же виртуальной машины [BEAM](https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)), появившемуся в 2012 году и активно развивающемуся. Этот язык получил более привычный большинству синтаксис, сохранив особенности Erlang, плюс обширные возможности [метапрограммирования](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).*

*Эрланг и Эликсир как два топора. Один старый, покрытый слоем застарелой окалины и окислов, с топорищем из неизвестной породы дерева, отполированным сотнями рук, но хорошо выкованный и правильно вручную заточенный. Второй - новенький топорик а-ля Фискарс из новейших сплавов и материалов. Но на одной и той же делянке леса с их помощью можно нарубить одинаковое количество. Просто кому-то будет удобнее со старым проверенным топором, а кому-то сподручнее с новым. Больше разницы никакой нет.*

*Некоторые термины и фразы я буду оставлять в тексте как есть, чтобы не выводить из контекста не совсем верным переводом.*

*Ссылки на понятия и комментарии от меня (переводчика) расположены в квадратных скобках `[]` и снабжены указателем "прим. переводчика".*

# Дзен Эрланга [и Эликсира - прим. переводчика]

Это свободный транскрипт (или долгий парафраз?) выступления на конференции ConnectDev'16, организованной Genetec, куда меня пригласили в качестве оратора.

![001](001.png)

Я полагаю, что большинство людей здесь никогда не использовало Эрланг, возможно, слышало о нём, может быть, только название. Поэтому данное выступление затронет только высокоуровневные концепции Эрланг, причём таким образом, что может оказаться полезным в ваших рабочих или сторонних проектах даже если вы никогда не сталкиваетесь с языком.

![002](002.png)

Если вы когда-либо интересовались Эрланг, то слышали об этом девизе - "Let it crash" [*"позволь этому рухнуть" - прим. переводчика*]. Моя первая встреча с ним заставила меня задуматься, что это за чертовщина? Предполагалось, что Эрланг отлично подходит для многопоточного выполнения и отказоустойчивости, а здесь мне говорят позволить всему падать, что полная противоположность поведению системы, которого я на самом деле хочу. Предложение удивительно, но «дзен» Эрланга, тем не менее, имеет к нему непосредственное отношение.

![003](003.png)

В некотором смысле было бы так же забавно использовать "Let it Crash" для Эрланга, как и "Blow it up" [*"подрывай это" - прим. переводчика*] для ракетостроения. "Подрыв", пожалуй, последнее, чего вы хотите в ракетостроении, и катастрофа Челленджера - яркое напоминание об этом. Однако если вы посмотрите на это иначе, то ракеты и их движительная система целиком имеют дело с опасным топливом, которое может и будет взрываться (и это рискованный момент), но делая это столь управляемым образом, что их можно использовать для организации космических путешествий или отправки полезных грузов на орбиту.

И суть здесь действительно в контроле; вы можете попытаться посмотреть на ракетостроение как на способ правильно укротить взрывы - или, по-крайней мере, их силу, - чтобы делать с ними то, что мы захотим. В свою очередь можно взглянуть на "Let it crash" под тем же углом: это об отказоустойчивости. Идея не в повсеместных бесконтрольных сбоях, она в том, чтобы превратить сбои, исключения и падения в инструменты, которые можно использовать.

Встречный пал [*[встречный пал](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D1%82%D1%80%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%B0%D0%BB) - прим. переводчика*] и управляемый отжиг - реальный пример борьбы с огнём при помощи огня. В регионе Сагене-Лак-Сен-Жан, откуда я родом, черничные поля регулярно сжигаются контролируемым образом, чтобы стимулировать и возобновить их рост. Довольно часто можно увидеть нездоровые участки леса, очищенные для предотвращения пожаров огнём так, чтобы это можно было сделать под надлежащим надзором и контролем. Основная цель заключается в том, чтобы удалить горючий материал таким образом, чтобы настоящий пожар не смог распространяться дальше.

Во всех этих ситуациях разрушительная сила огня, проходящего по посевам или лесам, используется для оздоровления посевов или предотвращения гораздо большего, неконтролируемого уничтожения лесных районов.

Я считаю, что смысл 'Let it crash' именно в  этом. Если мы можем воспользоваться сбоями, падениями и исключениями, и сделать это хорошо управляемым способом, они перестанут быть тем пугающим событием, которого необходимо избегать, и вместо этого превратятся в мощный строительный элемент для сборки больших надёжных систем.

![005](005.png)

Таким образом, вопросом становится то, как гарантировать, что сбои являются скорее созидательными, чем деструктивными. В Эрланге основной фишкой для этого является процесс. Процессы Эрланга полностью изолированы и имеют неразделяемую архитектуру (share nothing). Ни один процесс не может проникнуть в память другого или повлиять на выполняемую им работу, исказив рабочие данные. Это хорошо, поскольку означает, что умирающий процесс, по сути, гарантированно сохранит свои проблемы при себе, и обеспечивает очень сильную изоляцию отказов в вашей системе.

Процессы в Эрланге также чрезвычайно легковесны, настолько, что вы можете иметь тысячи и тысячи их без каких-либо проблем. Идея в том, чтобы использовать столько процессов, сколько вам нужно, нежели чем столько, сколько вы можете себе позволить. Создавая аналогию можно сказать, что если бы был объектно-ориентированный язык программирования, в которым в любой момент времени можно иметь максимум 32 объекта, работающих одновременно, вы бы быстро пришли к выводу, что ограничения слишком строгие и программировать на этом языке довольно нелепо. Наличие множества небольших процессов обеспечивает более высокую вариативность поломок, и в мире, где мы хотим поставить на службу силу сбоев это хорошо!

Теперь будет немного странным обрисовать то, как именно эти процессы работают. Когда вы пишете программу на C, у вас есть одна большая функция `main()`, которая делает много всего. Это ваша точка входа в программу. В Эрланге такой штуки нет. Ни один из процессов не является главным. Каждый процесс выполняет функцию, и эта функция играет роль `main()` этого конкретного процесса.

Теперь у нас есть рой пчёл, но, должно быть, довольно сложно отправить их укреплять улей, если они не могут коммуницировать каким-либо образом. Там, где пчёлы танцуют [*[танец пчёл](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%BD%D0%B5%D1%86_%D0%BF%D1%87%D1%91%D0%BB) - прим. переводчика*], процессы Эрланга обмениваются сообщениями.

![006](006.png)

Обмен сообщениями - наиболее интуитивная форма коммуникации в конкурентной среде. Она - одна из старейших, с которыми сталкивались, начиная с дней, когда мы писали письма и отправляли их курьерами на лошадях и до более причудливых механизмов вроде семафоров Наполеона [*[оптический семафор](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%82%D0%B5%D0%BB%D0%B5%D0%B3%D1%80%D0%B0%D1%84#%D0%A1%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80_%D0%B1%D1%80%D0%B0%D1%82%D1%8C%D0%B5%D0%B2_%D0%A8%D0%B0%D0%BF%D0%BF) - прим. переводчика*], показанного на иллюстрации. В последнем случае вы просто отправляется кучу парней на башни, отдаёте им сообщение, и они размахивают флажками для передачи данных на длинные расстояния способами, которые были быстрее выматывающихся лошадей. Постепенно такой способ сменился телеграфом, который, в свою очередь сменили телефон и радио, а сейчас у нас есть все эти модные технологии для передачи сообщений действительно далеко и действительно быстро.

Крайне важный аспект всего этого обмена сообщениями, особенно в старые времена, в том, что всё было асинхронным, и сообщения копировались. Никто не стоял на своём крыльце целыми днями в ожидании возвращения курьера и никто (я подозреваю) не сидел возле семафора, дожидаясь реакции. Вы отправляли сообщение и возвращались к своим делам, а со временем кто-то говорил, что вам пришёл ответ.

Это хорошо, потому что если другая сторона не реагирует, вы не застреваете на своём крыльце до самой смерти. С другой стороны и получатель на противоположном  конце канала связи не обнаруживает только что прибывшее сообщение исчезнувшим или изменившимся как по волшебству в тот момент, если вы действительно умрёте. При отправке сообщения данные должны быть скопированы. Эти два принципа гарантируют, что сбой во время коммуникации не приведёт к искажённому или невосстановимому состоянию [*[состояние](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) - прим. переводчика*]. Эрланг реализует оба.

У каждого процесса есть единый почтовый ящик для всех входящих сообщений. Каждый может написать процессу, но только владелец ящика может прочитать отправленное. По умолчанию сообщения обрабатываются в том порядке поступления, но с помощью возможностей типа сопоставления с образцом [*[сопоставление с образцом](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%86%D0%BE%D0%BC) - прим. переводчика*] возможно в конкретном случае или временно сфокусироваться на одном типе сообщений и поменять приоритеты.

![007](007.png)

Некоторые из вас заметят странность в том, я говорил; я продолжаю повторять, что изоляция и независимость настолько замечательны, что компонентам системы позволено умирать и падать, не влияя на остальные, но также я упоминал о коммуникации между множеством процессов или агентов.

Каждый раз в начале общения двух процессов создаётся неявная зависимость между ними. В системе появляется неявное состояние, которое связывает обоих между собой. Если процесс А отправляет сообщение процессу Б, и Б умирает, не ответив, А можно либо ждать ответа вечно, либо через какое-то время сдаться и отказаться от общения. Последнее - приемлемая стратегия, но очень неоднозначная: совершенно неясно, умерла ли удалённая сторона или просто так долго занята, и несвязанное сообщение приземлится в вашем ящике.

Вместо этого Эрланг даёт нам два механизм для решения: мониторы и связывание (links).

Мониторы - это о том, чтобы быть наблюдателем. Вы решаете присматривать за процессов, и если тот умирает по какой-то причине, в ваш почтовый ящик падает сообщение, сообщающее о случившемся. На это вы можете отреагировать на это и принять решение на основе недавно полученной информации. Второй процесс никогда не узнает, что вы всем этим занимались. Поэтому мониторы довольно хороши, если вы наблюдатель [*observer - наблюдаете за состоянием процессов - прим. переводчика*] или заботитесь о состоянии корреспондента.

Связи (links) - двунаправлены, и создание таковой связывает судьбу обоих связанных процессов воедино. Когда бы процесс ни умер, все связанные с ним процессы получат команду о выходе. Эта команда в свою очередь убьёт другие процессы.

Теперь всё это становится по-настоящему интересным, поскольку я могу использовать мониторы для быстрого обнаружения сбоев, и я могу использовать связывание как архитектурную конструкцию, позволяющую связать вместе несколько процессов так, чтобы сбой распространился на них как на единое целое. В момент, когда у моих независимых стротельных блоков появляются зависимости друг от друга, я могу начать вносить это в программу. Это полезно, поскольку предотвращает случайное падение системы в нестабильные частично изменённые состояния. Связи - инструмент, позволяющий разработчикам быть уверенными в том, что в конце, когда что-то ломается, оно ломается полностью и оставляет за собой чистый лист, по-прежнему не влияя на компоненты, не участвовшие в упражнении.

Для этой иллюстрации я выбрал изображение альпинистов, связанных страховочным фалом. Если альпинисты связаны только друг с другом, теперь они будут в жалком положении. Каждый раз при соскальзывании одного альпиниста остальная часть команды немедленно погибнет. Не очень хороший способ вести дела.

Вместо этого Эрланг позволяет указать, что некоторые процессы - особенные и пометить их опцией `trap_exit`. Тогда они смогут получать сигналы о выходе, отправленные через соединение, и преобразовывать их в сообщения. Это позволит им устранить неисправности и, возможно, загрузить новый процесс для совершения работы погибшего процесса. В отличие от альпинистов специальный процесс такого типа не может предотвратить падение партнёрского процесса; это уже ответственность партнёра, например, с помощью конструкций `try ... catch`. Процесс, который отлавливает выходы, по-прежнему не имеет возможности пойти поиграть с памятью другого и сохранить её, но может избежать совместной гибели.

Это становится очень важной возможностью для реализации супервизоров. Если вы никогда не слышали о них, то мы к ним вернёмся очень скоро.

![008](008.png)

Прежде, чем перейти к супервизорам, у нас всё ещё осталось несколько ингридиентов, чтобы успешно приготовить системы, которая использует падения для собственной пользы. Один из них связан с тем, как процессы планируются к запуску. Реальной аналогией для него, на которую я хотел бы сослаться, будет прилунение лунного модуля Аполлон-11 [*[Аполлон-11](https://ru.wikipedia.org/wiki/%D0%90%D0%BF%D0%BE%D0%BB%D0%BB%D0%BE%D0%BD-11) - прим. переводчика*].

Аполлон-11 - это миссия, отправившаяся на Луну в 1969 году. На этом изображении мы видим лунный модуль с Баззом Олдриным и Нейлом Армстронгом на борту, а фото сделано, я полагаю, Майклом Коллинзом, который остался в командном модуле.

На пути к посадке на Луну модуль управлялся Apollo PGNCS (Система первичного наведения, навигации и управления) [*[Apollo PGNCS](https://en.wikipedia.org/wiki/Apollo_PGNCS) - прим. переводчика*]. Система наведения выполняла несколько задач, тщательно рассчитанных под нужное количество циклов. NASA также указало, что процессор должен использоваться не более чем на 85% своей мощности, оставляя 15% свободными.

Поскольку космонавты хотели иметь надёжный резервный план на случай, если им придётся прервать миссию, они оставили включённым радар встречи с командно-служебным модулем - вдруг пригодится. Это заняло приличное количество оставшейся мощности CPU. Как только Баз Олдрин начал вводить комманды, стали появляться сообщения о переполнении и, по сути, о превышении доступной вычислительной мощности. Если бы система от этого свихнулась, то, вероятно, не смогла бы делать свою работу и всё закончилось бы двумя мёртвыми космонавтами.

В основном это произошло потому, что радар имел известную аппаратную проблему, вызывающую рассогласование его частоты с компьютером наведения, что вело к краже значительно большего количества циклов, чем использовалось бы в противном случае. Люди в NASA не были идиотами, и они повторно использовали проверенные компоненты, о редких ошибках которых они знали, вместо использования новых непроверенных технологий для столь критической миссии, но, что ещё более важно, они придумали диспетчеризацию по приоритетам.

Это означает, что даже в случае, когда этот радар или, возможно, введённые команды перегружали процессор, если их приоритет был слишком низок в сравнении с абсолютно жизненно-необходимыми вещами, задача была бы убита, чтобы дать циклы CPU тому, что на самом деле, по-настоящему в этом нуждается. Это было в 1969; сегодня всё ещё существует немало языков и фреймворков, дающих только кооперативную диспетчеризацию и ничего больше.

Эрланг - не тот язык, который стоит использовать для жизненно-важных систем, он учитывает только мягкие ограничения реального времени (soft-real time constraints), но не жёсткие ограничения реального времени, и поэтому использовать его для таких сценариев не будет хорошей идеей. Но Эрланг предоставляет диспетчеризацию по приоритетам [*она же - вытесняющая многозадачность - прим. переводчика*] и приоритезацию процессов. Это означает, что вам как разработчику или архитектору системы не нужно заботиться, чтобы для предотвращения подвисаний абсолютно все тщательно рассчитывали нагрузку на CPU, требуемую для их компонентов (включая используемые библиотеки). Им просто не продоставят такой мощности. И если нужно, чтобы какая-то важная задача выполнялась всегда, когда это необходимо - вы так же можете это обеспечить.

Это может не выглядеть как серьёзное или частое требование, и люди всё ещё выпускают действительно успешные проекты, основанные исключительно на кооперативной диспетчеризации параллельных процессов, но, безусловно, исключительно ценно, поскольку защищает вас от чужих ошибок, равно и как от ваших собственных. Это также открывает двери для таких механизмов, как автоматическое распределение нагрузки, "наказание хороших" или "поощрение плохих" процессов или назначение более высоких приорететов процессам с большой очередью задач. Всё это в конечном итоге делает ваши системы достаточно адаптируемыми к нагрузкам и непредвиденным событиям.

![009](009.png)

Последний компонент, который я хотел бы обсудить в рамках обеспечения достойной отказоустойчивости - это возможность работы в сети. В любой системе, которая разрабатывается с прицелом на долговременную активность, возможность работать на более чем одном компьютере быстро становится обязательным требованием. Вы не захотите сидеть где-то там запертым за титановыми дверями со своей золотой машиной, не имея возможности компенсировать любые отказы, влияющие главным образом на ваших пользователей.

Так что рано или поздно вам понадобится два компьютера, чтобы один выжил при поломке второго, и, возможно, третий, если появится желание развернуть часть вашей системы во время поломок.

Самолёт на иллюстрации - F-82 "Твин Мустанг" [*[F-82 "Твин Мустанг"](https://ru.wikipedia.org/wiki/North_American_F-82_Twin_Mustang) - прим. переводчика*], воздушное судно, разработанный во время второй мировой войны для сопровождения бомбардировщиков на расстояния, которые большинство других исстребителей просто не могли преодолеть. У него было две кабины, так что пилоты могли сменять друг друга при управлении; в нужный момент была возможность разделить обязанности так, что один пилот мог вести самолёт, а второй - управлять радарами в роли перехватчика. Современные воздушные суда всё ещё имеют подобные возможности; у них есть бесчисленные дублирующие системы, и часто члены экипажа спят во время полёта, чтобы при необходимости всегда был кто-то готовый немедленно принять управление самолётом.

Что касается языков программирования или контуров разработки, то большинство из них спроектированы без возможности распределённой работы, пусть и понятно, что при  разработке серверного стека вам понадобится работать более чем с одним сервером. С другой стороны, если вы собираетесь работать с файлами - в стандартной библиотеке есть инструменты для этого. Максимум, что вам может дать большинство языков - это поддержка сокетов или HTTP-клиент.

Эрланг отдаёт должное реальности распределённых систем и предлагает реализацию для этого, которая задокументирована и прозрачна. Это позволяет реализовывать хитрую логику для обработки отказов или переназначения функций упавших приложений с целью предоставить большую отказоустойчивость или даже чтобы позволить другим языка притворяться узлами Эрланга для построения систем-полиглотов [*[pylyglot systems](https://en.wikipedia.org/wiki/Polyglot_(computing)) - прим. переводчика*].

![010](010.png)

Таковы основные ингредиенты в рецепте для достижения дзена Эрланга. Весь язык построен с целью устранения и превращения сбоев и падений во что-то столь управляемое, что становится возможным использовать их в качестве инструмента. Лозунг "Let it crash" получает смысл, и применяемые тут принципы могут использоваться и в системах, реализуемых на других языках.

Собрать их вместе - следующее испытание.

![011](011.png)

Деревья наблюдателей (supervision trees) - то, с помощью чего вы реализуете структуру ваших программ на Эрланг. Они начинаются с простой концепции - супервизора (наблюдателя), - единственная задача которого - стартовать, отслеживать и перезапускать процессы в случае падений. Кстати, супервизор - один из основных компонентов "OTP", главного фреймворка разработки, вынесенного в название "Erlang/OTP" [*[OTP - Open Telecom Platform](https://ru.wikipedia.org/wiki/Open_Telecom_Platform) - прим. переводчика*].

Цель деревьев наблюдения - создать иерархию, в которой все важные вещи, которые должны быть максимально надёжными, аккумулирются ближе к корню дерева, а временные, "движущиеся" части располагаются у его листьев. Фактически, именно так настоящие деревья и выглядят: листья подвижны и их много, они опадают осенью, но дерево остаётся живым.

Это означает, что при структурировании программы на Эрланг всё, что вам кажется ненадёжным и чему позволено ломаться должно располагаться глубже в иерархии, а всё, что стабильно и критически важно - выше.

![012](012.png)

Супервизоры реализуют это с помощью связывания и захвата уведомлений о выходе (trapping exits). Их работа начинается с запуска дочерних процессов в порядке "сверху вниз, слева направо). Только после того, как однин дочерний процесс полностью запущен происходит возврат на тот же уровень и начинает запускаться следующий. Каждый дочерний процесс автоматически связывается с со своим супервизором.

При смерти дочернего процесса выбирается одна из трёх стратегий. Первая стратегия на иллюстрации называется "один за одного" (one for one) и заключается в замене только одного погибшего процесса. Эту стратегия используется, когда все потомки этого супервизора независимы друг от друга.

Вторая стратегия - "один за всех" (one for all). Она применяется в случаеях, когда все потомки зависят друг от друга. Когда погибает один из них, супервизор убивает остальные потомки перед тем, как вновь их запустить. Её стоит использовать, если потеря конкретного потомка оставит остальных в неопределённом состоянии. Представьте себе обмен сообщениями между тремя процессами, который завершается выбором. Вполне возможно, что мы не написали код, обрабатывающий гибель одного из процессов. Замена погибшего потомка новым приведёт к появлению нового участника, который тоже понятия не имеет о том, что происходит!

Подобное неконсистентное состояние теоретически опасно, если мы не определили, что происходит, когда один из процессов вносит сумятицу в процедуру голосования. Возможно, безопаснее просто убить все процессы и начать заново с известного стабильного состояния. Делая это мы уменьшаем область ошибок: лучше упасть сразу и быстро, чем медленно портить данные на долгосрочной основе.

Последняя стратегия полезна всякий раз, когда зависимость процессов связана с порядком загрузки. Её название - "оставшиеся за одного" (rest for one), и заключается она в том, что если потомок умирает, уничтожаются только те его собратья, которые были запущены после него. Затем процессы перезапускаются в том же порядке.

Дополнительно каждый супервизор имеет настраиваемые элементы управления и "уровень терпимости". Некоторым супервизорам можно до собственного аварийного завершения допустить только 1 сбой потомка в день, в то время как другим разрешено позволять 150 сбоев в секунду.

![013](013.png)

Комментарии, которые обычно появляются после упоминания о супервизорах, обычно звучат в стиле "но если мой конфигурационный файл повреждён, перезапуск ничего не исправит!"

Совершенно верное замечание. Причина, по которой перезапуск работает, заключается в природе ошибок, выявленных в промышленной экплуатации систем. Для обсуждения причин я хотел бы сослаться на термины "Гейзенбаг" [*[Гейзенбаг](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%B9%D0%B7%D0%B5%D0%BD%D0%B1%D0%B0%D0%B3) - прим. переводчика*] и "Борбаг" [*[Борбаг](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%B9%D0%B7%D0%B5%D0%BD%D0%B1%D0%B0%D0%B3#%D0%A1%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F) - прим. переводчика*], придуманные Jim Gray в 1985 году (я определённо рекомендую ознакомиться со всеми доступными вам статьями Jim Gray, они практически все великолепны!)

По-сути, борбаг - это ошибка, которая постоянна, наблюдаема и легко повторяема. Обычно их довольно легко объяснить. В отличие от него гейзенбаги имеют непостоянное поведение, появляющееся только при определённых обстоятельствах, и могут скрываться в результате самого факта попытки их обнаружить. Например, при использовании отладчика ошибки, связанные с многопоточностью, нередко исчезают, поскольку отладчик упорядочивает операции в системе.

Гейзенбаги - это те надоедливые ошибки, которые случаются один из тысячи, миллиона, миллиарда или триллиона. Понять, что кто-то уже некотороде время пытается обнаружить подобную ошибку, можно увидев, как он распечатывает страницы кода и, взяв кучу маркеров, уходит в работу над ними.

Определив терминологию давайте посмотрим, как часто эти типы ошибок появляются.

![014](014.png)

На иллюстрации я классифицирую борбаги как повторяемые, а гейзенбаги - как случайные.

Если борбаги присутствуют в основном функционале вашей системы, то обычно их очень просто обнаружить ещё до отгрузки системы в эксплуатацию. Будучи повторяемыми и находясь зачастую в критически важных модулях они обнаруживаются рано или поздно и исправляются до отгрузки.

Те, что случаются во вторичных, менее часто используемых функциях, гораздо больше зависят от небрежности. Любой согласится, что попытка исправить все ошибки в системе - это неравный бой с убывающей отдачей; выпалывание всех этих маленьких изъянов требует по мере продвижения непропорционально больше времени. Обычно второстепенные функции привлекают меньше внимания, поскольку либо использовать их будет меньше заказчиков, либо влиять на удовлетворённость пользователей они будут не так сильно. Или, как вариант, их исправить планируется позднее, и скользящий график в конце концов постоянно сдвигает сроки.

В любом случае, их легко найти, мы просто не хотим тратить время или ресурсы на это.

Гейзенбаги же найти во время разработки практически невозможно. Модные способы вроде формальных доказательств, проверки модели, исчерпывающего тестирования или тестирования на основе свойств [*[Property-Based Testing Basics](https://ferd.ca/property-based-testing-basics.html), [Property-based testing](https://medium.com/@vporoshok/property-based-testing-642cb7f9817f)  - прим. переводчика*] могут увеличить вероятность все или часть из них (в зависимости от используемых инструментов), но будем честны - немногие из нас используют хоть что-то из этого, если только не решают критически важную задачу. Чтобы обнаружить проявляющуюся один раз на миллиард ошибку требуется довольно много тестов и проверок, и есть вероятность, что даже если вы её обнаружили, не сможете повторить снова.

![015](015.png)

В качестве следующей вводной я хотел бы рассмотреть частоту появления каждого из этих типов ошибок в продуктивной эксплуатации (с точки зрения моего опыта). Не существует очевидных доказательств связи между привычкой искать ошибки и частотой их проявления в эксплуатируемых системах, но моё внутреннее чувство говорить, что такая связь есть.

Прежде всего, легко повторяемые ошибки в основных функциях просто не должны попадать в эксплуатацию. Если это случается, вы, по сути, отгрузили нерабочий продукт, и никакое количество перезапусков не поможет вашим пользователям. Такие ошибки требуют модификации кода и могут быть результатом некоторых глубоко укоренившихся проблем организации-разработчика.

Повторяемые ошибки в побочных функциях довольно часто попадают в эксплуатацию. Я считаю, что это результат недостаточного тестирование, но существует также большая вероятность, что вторичные функции часто остаются без внимания, когда речь идет о частичном рефакторинге, или что люди, занимающиеся проектированием таких функций, не в полной мере учитывают их согласованность и соответствие остальной части системы.

С другой стороны, случайные ошибки будут появляться всё чёртово время. Jim Gray, придумавший эти термины, говорил, что на 132 ошибки, замеченных у определённого количества клиентов, только одна была борбагом. 131 из 132 ошибок, найденных в эксплуатации, были гейзенбагами. Их тяжело поймать, и если это действительно статистические ошибки, то они могут показаться один раз из миллиона, просто потребуется некоторая нагрузка на вашу систему для того, чтобы они проявлялись постоянно; ошибка, возникающая в одном случае на миллиард, будет появляться каждые 3 часа в системах, обрабатывающих 100 000 запросов в секунду, а если ошибка возникает один раз на миллион -  в такой системе она будет показываться каждые 10 секунд, но в тестах её проявление будет по-прежнему редким.

Это очень много ошибок, и очень много сбоев, если не обрабатывать их правильно.

![016](016.png)

Так насколько на самом деле эффективна перезагрузка в качестве стратегии?

Ну, для повторяемых ошибок в основных функциях системы перезагрузка бесполезна. Для повторяемых ошибок в менее часто используемых фрагментах кода могут быть варианты; если функция очень важна для очень небольшого количества пользователей, перезагрузка мало что исправит. Если второстепенная функция используется всеми, но не сильно их заботит перезагрузка или игнорирование сбоя могут сработать. Например, если бы функция "Подмигнуть" на Facebook была сломана (если бы всё ещё существовала), не особо много пользователей обратило бы на это внимание или посчитало, что их впечатление от пользования Facebook в результате этого сбоя оказалось негативным.

Поэтому для случайных ошибок перезагрузка чрезвычайно эффективна, а таковые, как правило, составляют основную массу ошибок, с которыми вы столкнётесь вживую. Поскольку их сложно воспроизвести из-за того, что их появление зачастую зависит от очень специфических обстоятельств или сочетаний фрагментов данных в системе, перезагрука скорее всего заставит их исчезнуть.

Возврат к доподлинно стабильному состоянию и новая попытка вряд ли приведёт к той же ненормальной ситуации, вызвавшей ошибку. Именно так: то, что могло бы стать катастрофой превратилось едва ли в более, чем небольшую заминку, с которой некоторые пользователи быстро учатся жить.

Позднее вы сможете использовать логгирование, трассировку или различные инструменты диагностических инструментов (все из которых включены в Эрланг по-умолчанию), чтобы найти, понять и исправить проблемы окончательно. Или решить, что эти проблемы трогают вас меньше, потому как усилий для их устранения нужно приложить слишком много.

![017](017.png)

Вопрос на иллюстрации мне задали на форме, где я обсуждал всякую всячину о программировании, в том числе обсуждал модель Эрланга. Я скопировал его дословно, поскольку это отличный пример вопроса, который задаёт множество людей, услышав о перезапуске и возаожмностях Эрланга.

Я хочу разобрать ситуацию предметно, на реальном примере показав, как на Эрланге можно спроектировть систему, что продемонстирует его особенности.

![018](018.png)

С помощью супервизоров (квадраты) мы можем начать создавать глубокие иерархии процессов. В данном случае речь идёт и системе выборов, с двумя деревьями: дерево итогов и дерево отчётов в реальном времени. Дерево итогов служит для подсчёта и хранения результатов, а дерево отчётов даёт людям возможность подключаться для просмотра результатов.

В соответствии с порядком определения потомков отчеты в реальном времени не будут запускаться до тех пор, пока дерево итогов не загрузится и не начнёт функционировать. Дерево округов (служит для расчёта результатов на уровне округа) не запустится до того, как станет доступным слой хранения. Кэш подсистемы хранения запустится только если заработает пул рабочих процессов (которые обеспечивают соединение с базой данных).

Стратегии наблюдения (supervision strategies), о которых я упоминал ранее, позволяют нам явно указать эти требования в структуре программы, и они будут соблюдаться и во время выполнения, а не только в момент запуска. Например, супервизор итогов может использовать стратегию "один за одного", подразумевая, что индивидуальные супервизоры округов могут аварийно завершаться, не влияя на подсчёты других округов. В противоположность этому каждый округ (супервизоры Квебека и Онтарио) могут использовать стратегию "все за одного". В результате эта стратегия гарантирует, что процесс распознавания (OCR) всегда может отправить обнаруженные голоса в процесс счётчика и может часть падать, не влияя на подсчёт. С другой стороны, если процесс счётчика не может хранить и передавать результаты в базу данных, его гибель прерывает процедуру распознавания, гарантируя, что ничего не теряется.

Ещё один момент, который стоит упомянуть, заключается в том, что каждый супервизор имеет конфигурируемую устойчивость к отказам; супервизоры округов могут быть очень устойчивыми и позволять 10 сбоев в минуту, в то время как слой хранения для корректной работы может быть настроен наблюдать не более 3 падений в час, если мы так решим.

В этой программе критически важные функции, неподвижные и надёжные, находятся ближе к корню дерева. Их не затрагивает гибель других сиблингов, но собственные сбои влияют на всех остальных. Листья при этом делают всю работу и могут быть потеряны довольно легко - как только они впитали данные и провели на них фотосинтез, им разрешено уйти к праотцам. 
## TODO: подумать над оборотом, не уверен, что перевод верный: The leaves do all the work and can be lost fairly well — once they have absorbed the data and operated their photosynthesis on it, it is allowed to go towards the core.

Таким образом, определив все это, мы можем изолировать рискованный код в рабочем процессе с жёстким допуском или в процессе, который отслеживается, и перемещать данные в более стабильные процессы по мере консолидации информации в системе. Если код OCR на C нестабилен, он может упасть и может быть безопасно перезапущен. Во время работы он передает свою информацию в OCR процесс Эрланга. Упомянутый процесс может выполнить валидацию, возможно, сам аварийно завершившись, а возможно и нет. Если информация достоверна, он перемещает ее в процесс Счётчик, который хранит и обрабатывает очень простого состояния, и, в конечном итоге, сбрасывает это состояние в базу данных через независимое поддерево хранилища.

Если процесс OCR умирает, он перезапускается. Если он умирает слишком часто, его собственный супервизор завершается, и эта часть поддерева тоже перезапускается - не влияя на остальную часть системы. Если это что-то испрвило - отличо. Если нет, процесс повторяется на более высоком уровне, либо пока ошибка не исченет, либо пока вся система не будет остановлена, поскольку что-то явно не так, и справиться с этим с помощью перезапусков нельзя.

Такое структурирование системы имеет огромное значение, поскольку обработка ошибок встроена в её структуру. Это значит, что можно перестать писать чрезмерно защитный код для пограничных узлов - если что-то идёт не так, пусть кто-то другой (или структура программы) диктует, как реагировать. Если я знаю, как справиться с ошибкой - отлично, я могу сделать это для конкретной ошибки. В противном случае - let it crash!

Это ведёт к изменению кода. Постепенно вы замечаете, что он уже не содержит тонны этих `if/else`, или `switch`ей, или `try/catch`. Вместо этого в нём присутствуют разборчивые инструкции, объясняющие, что необходимо делать, когда всё идёт хорошо. Там перестаёт появляться множество форм догадок [*о том, что может пойти не так - прим. переводчика*], и код становится значительно более читабельным.

![019](019.png)

Если сделать шаг назад и посмотреть на структуру нашей программы, мы на самом деле обнаружим, что каждое из поддеревьев, обведённых жёлтым, выглядит в основном независимыми друг от друга с точки зрения своих задач; их зависимости в основном логические: например, системе отчётов требуется слой хранения для получения данных.

Было бы здорово, если бы можно было, например, поменять реализацию хранилища или воспользоваться ей в других проектах. Также было бы неплохо изолировать систему отчетов на друшлм узле или начать предоставлять альтернативные средства получения информации (например, SMS).

Теперь нам нужно найти способ разбить эти поддеревья и превратить их в логические единицы, которые можно компоновать, повторно использовать друг с другом, и которые в иных случаях можно настраивать, перезапускать или разрабатывать независимо.

![020](020.png)

В качестве решения для этой задачи Эрланг использует приложения OTP. OTP-приложение - это в основном код для построения такого поддерева, сопровождаемый некоторыми метаданными. Эти метаданные содержат базовые сведения вроде номера версии и описания того, что делает данное приложение, а также указывают на зависимости между приложениями. Это полезно, поскольку позволяет сохранять приложение хранилища данных независимым от остальной части системы, при этом указывая, что оно необходимо для работы приложению итогов. Можно сохранить всю информацию, которая уже закодирована в системе, но теперь система будет состоять из независимых блоков, которыми проще распоряжаться.

Фактически, в Эрланг люди рассматривают OTP-приложения как библиотеки. Если ваша кодовая база не оформлена как OTP-приложение, её невозможно повторно использовать в других системах. [Примечание: существует возможность использовать OTP-библиотеки, которые на самом деле не содержат деревья процессов, а только код для повторного использования]

В результате наша система на Эрланге описывает все нижеприведённые свойства:

- что критично для выживания системы, а что нет;
- для каких частей системы сбои недопустимы, а для каких разрешены, и как часто они могут происходить до того, как с ними больше невозможно будет мириться;
- как приложение должно загружаться в соответствии с требуемыми гарантиями, и в каком порядке;
- какой уровень ошибок допустим для приложение, подразумевая, что определяется допустимый уровень частичных сбоев, и как откатиться до известного стабильного состояния в моменты, когда они случаются;
- как приложение обновляется (поскольку может производить обновление кода онлайн, основываясь на структуре супервизоров);
- как и какие компоненты зависят друг от друга.

Всё это чрезвычайно ценно. Ещё более ценно то, что это заставляет разработчика с самого начала мыслить в соответствующих терминах. Вы получаете меньше защитного кода, и когда плохие вещи случаются, система продолжает работать. Всё, что вам нужно - это посмотреть в логи или проанализировать состояние системы онлайн и получив достаточно времени для исправления ошибок, если почувствуете, что это стоит затраченного времени.

![021](021.png)

После всего этого я смогу спокойно спать по ночам, верно? Надеюсь, да. Привожу здесь небольшую диаграмму, полученную после развертывания нового программного продукта, который мы запустили на Heroku пару лет назад.

Самая левая часть диаграммы относится примерно к сентябрю. К тому моменту наш новый проксирующий слой (vegur) был в эксплуатации, пожалуй, около 3 месяцев, мы отутюжили большинство шероховатостей в нём. У пользователей не было проблем, переход прошёл гладко, и новые возможности уже использовались.

В какой-то момент один из членов команды получил очень внушительный счёт за использование сервиса логгирования, который собирал информацию об исключениях. Именно тогда мы обнаружили ужас, отображённый в левой части диаграммы: генерировалось от 500 000 до 1 000 000 исключений в день! Святая корова, это много. Но много ли? Если дело было в гейзенбаге, и наша система обрабатывала, скажем, 100 000 запросов в секунду, какова вероятность происходящего? Что-то между 1:17000 и 1:7000. Довольно часто, но так как это не оказывало никакого влияния на наш сервис, мы ничего не замечали, пока не получили счёт.

Поиск ошибки не занял много времени, и мы всё починили. Можно заметить, что небольшое количество исключений после этого осталось, может быть, пара десятков тысяч в день. Мы знаем о них, но никакого влияния они не оказывают. Прошло два года, и мы всё ещё не озаботились исправленим, потому что система работает хорошо и так.

![022](022.png)

В то же время вы не можете всегда просто спокойно спать по ночам. Сбои могут быть вне вашего контроля не смотря на все усилия по проектированию.

Пару лет назад я летел в Ванкувер, и во время снижения пилот в интерком сказал что-то вроде: "говорит ваш капитан, мы скоро приземлимся. Пожалуйста, не волнуйтесь, мы задержимся на рулёжной дорожке на несколько минут, пока самолёт осмотрят пожарные. Мы потеряли часть гидравлического компонента, и они хотят убедиться, что нет риска возгоряния. У нас есть две запасных системы взамен сломавшейся, так что всё должно быть нормально."

И всё было нормально. Самолёт оказался удивительно хорошо спроектирован для подобных ситуаций.

Но фото на иллюстрации не тот самолёт, это другой, которым я летел две недели назад, когда восточная часть США была засыпана снегом толщиной 60 см. Самолёт (рейс United 734), который, я уверен, максимально надёжен, приземлился на взлётно-посадочную полосу. Однако когда пришло время тормозить, он издал громкий звук, который, как я полагаю, шёл от самолётного аналога ABS, но продолжал движение.

Мы проехали над красными огнями в конце полосы, которые вы видите на фото, и в конце концов самолёт сошёл с полосы, преодолел концевую полосу безопасности и переднее колесо в конце-концов закончило своё движение на траве. Всё было нормально, но это пример того, почему прекрасные инженерные решения не всегда спасают ситуацию.

![023](023.png)

Фактически, эксплуатационная поддержка будет всегда оставаться огромным фактором успешного развёртывания систем. Данная иллюстрация была в большой степени навеяна (а по факту, скорее украдена из) выступлением Richard Cook. Если вы с ним не знакомы, я призываю посмотреть видео его лекций на YouTube, они практически все фантастические. 

Правильные архитектура приложений и методы разработки по-прежнему не могут заменить или могут быть дезавуированны неадекватной эксплуатационной поддержкой; эффективность и полезность инструментов, инструкций, мониторинга, автоматизации и т.д., все они неявно полагаются на знание и соблюдение чётко определённых условий работы (пропускной способности, нагрузок, управления перегрузками и т.п.) Когда они описаны, эти эксплуатационные ограничения дают понять, когда дела вот-вот пойдут плохо и когда всё снова стало хорошо.

Проблема с этими ограничениями в том, что когда операторы привыкают к ним и привыкают часто нарушать их без негативных последствий, появляется риск медленного движения к краю опасной зоны, где происходят неприятные крупномасштабные отказы. Сроки вашей реакции и запас времени на адаптацию к более высоким нагрузкам сокращаются, и в конечном итоге вы оказываетесь в положении, когда что-то постоянно ломается без какой-либо передышки в обозримом будущем.

Поэтому мы должны быть осторожны и осознавать подобные вещи, как и то, насколько важны для в этих ситуациях люди, использующие и эксплуатирующие программное обеспечение. Масштабировать хорошую команду всегда сложнее, чем программу. Планируйте действия в чрезвычайных ситуациях даже если они не происходят; когда-нибудь это случится, и вы будете рады, что моделировали ситуацию и подготовили инструкции, следуя которым можно всё это исправить.

![024](024.png)

В случае с моим рейсом, как я уже сказал, никто не пострадал. Тем не менее, посмотрите на цирк, который развернули вокруг: автобусы для сопровождния пассажиров в терминал, так как перещение сошедшего с полосы самолёта рискованно. Внедорожники для безопасного сопровождения автобусов с полосы до терминала. Полицейские автомобили, множество пожарных машин и тот чёрный автомобиль, неизвестно для чего нужный, но наверняка очень полезный.

Они развернули всё это несмотря на то, что все были в норме, несмотря на то, что самолёты очень надёжны. Они делают всё правильно.

![025](025.png)

Вот ещё куча всего, что вы получите, используя Эрланг. На самом деле мне особо нечего сказать об этом, просто я несколько заинтересова в том, чтобы вы начали это всё использовать, так что вот вам.

Хотя последний пункт заслуживает комментария. Один из рисков в языках, которые склонны к компромисам в своём подходе к проектированию систем в том, что используемые вами библиотеки могут делать что-то не так, как, по вашему мнению, более уместно в данной ситуации, и вы либо отказываетесь от использования библиотеки, либо приходится мириться с кодовой базой с непоследовательным дизайном. С Эрлангом такого не случится, посколько все используют один и тот же проверенный подход для выполнения своих задач.

![026](026.png)

Короче говоря, дзен Эрланга и 'let it crash' - это всё о том, чтобы выяснить, как компоненты взаимодействуют друг с другом, чтобы выяснить, что критично, а что - нет, какое состояние можно сохранить, оставить, вычислить заново и потерять. Во всех случаях вам нужно придумать самый худший сценарий и способы его пережить. Используя механизмы fail-fast с изоляцией, связыванием и мониторами, и супервизорами для органичения масштабов и эскалации всех этих наихудших сценариев, вы превращаете их в по-настоящему хорошо известный случай стандартного сбоя.

Это звучит просто, но работает на удивление хорошо; если вы считаете, что возможно пережить ваш случай хорошо проработанного стандартного сбоя, то можете исключить его из обработчика ошибок. Больше не нужно беспокоиться или писать защитный код. Вы пишете, что код должен делать и позволяете структуре программы управлять остальным. Let it crash.

![027](027.png)

Вот что такое дзен Эрланга: сначала постороить взаимодействия, удостоверившись, что наихудшее, что может случиться - всё равно нормально. Затем в вашей системе случится немного падений или сбоев, просто чтобы заставить вас понервничать (и когда это случится, вы сможете продиагностировать всё прямо онлайн!). Откиньтесь на спинку кресла и расслабьтесь.